<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Física Aplicada</title>
    <link rel="stylesheet" type="text/css" href="css/styles.css">
    <!-- Incluir Plotly.js -->
    <script src="js_lib/plotly-latest.min.js"></script>
    <!-- Incluir math.js -->
    <script src="js_lib/math.min.js"></script>
    <script src="js/menuData.js"></script>
    <script src="js/generarMenu.js"></script>
    <script src="js_lib/chart.js"></script>
    <script id="MathJax-script" async
            src="js_lib/tex-mml-chtml.js">
    </script>
    <style>
        /* Reset básico */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        /* body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            min-height: 100vh;
            background-color: #f0f2f5;
        }

        #sidebar {
            width: 300px;
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            overflow-y: auto;
        }
        #sidebar h1 {
            font-size: 1.5em;
            margin-bottom: 20px;
            text-align: center;
        }
        #controls label {
            display: block;
            margin-top: 15px;
            font-weight: bold;
        }
        #controls input {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            border: none;
            border-radius: 4px;
        } */
        #tramos {
            margin-top: 20px;
        }
        .tramo {
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        .tramo h4 {
            margin-bottom: 10px;
        }
        .tramo label {
            display: block;
            margin-top: 10px;
        }
        .tramo input {
            width: 100%;
            padding: 6px;
            margin-top: 5px;
            border: none;
            border-radius: 4px;
        }
        .tramo button {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 8px;
            margin-top: 10px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }
        .tramo button:hover {
            background-color: #c0392b;
        }
        #addTramo {
            background-color: #27ae60;
            color: white;
            border: none;
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }
        #addTramo:hover {
            background-color: #219150;
        }
        /* #buttons {
            margin-top: 20px;
        }
        #buttons button {
            width: 48%;
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            color: white;
            margin-right: 4%;
        }
        #buttons button:last-child {
            margin-right: 0;
        }
        #startButton {
            background-color: #2980b9;
        }
        #startButton:hover {
            background-color: #1f6391;
        }
        #resetButton {
            background-color: #f39c12;
        }
        #resetButton:hover {
            background-color: #d9820f;
        }

        #main {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        #main h1 {
            text-align: center;
            margin-bottom: 20px;
        } */
        /* Sección de Ecuaciones */
        /* #equations {
            max-width: 800px;
            margin: 0 auto 30px auto;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #equations h3 {
            margin-bottom: 15px;
            text-align: center;
            color: #2c3e50;
        } */
        /* Animación */
        #animationArea {
            border: 2px solid #2c3e50;
            width: 100%;
            max-width: 800px;
            height: 120px;
            position: relative;
            margin: 0 auto 30px auto;
            overflow: hidden;
            background-color: #ecf0f1;
            border-radius: 8px;
        }
        #object {
            width: 30px;
            height: 30px;
            background-color: #e74c3c;
            position: absolute;
            top: 45px;
            left: 0;
            border-radius: 50%;
            transition: left 0.1s linear;
        }
        .chart-container {
            width: 100%;
            max-width: 800px;
            height: 300px;
            margin: 0 auto 30px auto;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        /* Tabla de cálculos */
        /* #calculationsContainer {
            width: 100%;
            max-width: 800px;
            margin: 0 auto 30px auto;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            overflow-x: auto;
        }
        #calculationsContainer h3 {
            margin-bottom: 15px;
            text-align: center;
            color: #2c3e50;
        }
        #calculations table {
            width: 100%;
            border-collapse: collapse;
        }
        #calculations th, #calculations td {
            padding: 10px;
            border: 1px solid #bdc3c7;
            text-align: center;
        }
        #calculations th {
            background-color: #34495e;
            color: white;
        } */
        /* Responsive */
        @media (max-width: 1200px) {
            #sidebar {
                width: 250px;
            }
            #main {
                padding: 15px;
            }
            .chart-container, #animationArea, #calculationsContainer, #equations {
                max-width: 100%;
            }
        }
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
            #sidebar {
                width: 100%;
            }
            #buttons button {
                width: 100%;
                margin-right: 0;
                margin-bottom: 10px;
            }
            #buttons button:last-child {
                margin-bottom: 0;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Movimiento Rectilíneo Uniforme y Uniformemente Variado</h1>
    </header>
    <nav>
        <!-- Navegación opcional -->
    </nav>
    <div class="parametros">
        <aside id="sidebar">
            <h2>Parámetros</h2>

            <div class="slider-container">
                <label for="initialPosition">Posición Inicial (x₀):</label>
                <input type="number" id="initialPosition" value="0">
            </div>
            <div class="slider-container">
            <label for="totalTime">Tiempo Total:</label>
            <input type="number" id="totalTime" value="5" readonly> 
        </div>

        <div id="tramos">
            <h3>Tramos de Movimiento</h3>
            <div class="tramo" data-tramo="1">
                <h4>Tramo 1</h4>
                <label for="velocity1">Velocidad Inicial (v₀₁):</label>
                <input type="number" id="velocity1" value="50" readonly>

                <label for="acceleration1">Aceleración (a₁):</label>
                <input type="number" id="acceleration1" value="10"> 

                <label for="duration1">Duración (t₁):</label>
                <input type="number" id="duration1" value="5">

                <button class="removeTramo">Eliminar Tramo</button>
            </div>
        </div>
    <div class="slider-container">
        <button id="addTramo">Agregar Tramo</button>
    </div>
    <div class="slider-container">

            <button id="startButton">Iniciar</button>
        </div>
        <div class="slider-container">
            <button id="resetButton">Reiniciar</button>
        </div>
    </aside>
</div>
<main id="content"> 
    <div id="main">
        

        <!-- Sección de Ecuaciones -->
        <h3>Ecuaciones del Movimiento</h3>
        <div id="equations" class="ecuacion">
            
            <p><strong>Movimiento Rectilíneo Uniforme (MRU):</strong></p>
            <p>$$ x(t) = x_0 + v t $$</p>
            <p><strong>Movimiento Rectilíneo Uniformemente Variado (MRUV):</strong></p>
            <p>$$ x(t) = x_0 + v_0 t + \frac{1}{2} a t^2 $$</p>
            <p>$$ v(t) = v_0 + a t $$</p>
        </div>

        <div id="animationArea">
            <div id="object"></div>
        </div>
        <h3>Cálculos por Tramo</h3>
        <div id="calculationsContainer" class="resultado">
            
            <table>
                <thead>
                    <tr>
                        <th>Tramo</th>
                        <th>Velocidad Inicial</th>
                        <th>Aceleración</th>
                        <th>Tiempo</th>
                        <th>Velocidad Final</th>
                        <th>Espacio Recorrido</th>
                    </tr>
                </thead>
                <tbody id="calculationsBody">
                    <!-- Las filas se generarán dinámicamente -->
                </tbody>
            </table>
        </div>
        <div class="chart-container">
            <canvas id="spaceTimeChart"></canvas>
        </div>

        <div class="chart-container">
            <canvas id="velocityTimeChart"></canvas>
        </div>

        <div class="chart-container">
            <canvas id="accelerationTimeChart"></canvas>
        </div>
       
    </div>
</main>
<br>
<footer>
    &copy; 2024 Física Aplicada - dgiuliodori@unc.edu.ar 
</footer>
    <script>
        // Obtener elementos del DOM
        const initialPositionInput = document.getElementById('initialPosition');
        const totalTimeInput = document.getElementById('totalTime');
        const addTramoButton = document.getElementById('addTramo');
        const tramosContainer = document.getElementById('tramos');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const object = document.getElementById('object');
        const animationArea = document.getElementById('animationArea');
        const spaceTimeCtx = document.getElementById('spaceTimeChart').getContext('2d');
        const velocityTimeCtx = document.getElementById('velocityTimeChart').getContext('2d');
        const accelerationTimeCtx = document.getElementById('accelerationTimeChart').getContext('2d');
        const calculationsBody = document.getElementById('calculationsBody');

        let tramoCount = 1;

        // Función para actualizar los tramos: recalcula v0 y totalTime
        function updateTramos() {
            const tramoDivs = tramosContainer.querySelectorAll('.tramo');
            let currentV0 = 0;
            let totalDuration = 0;

            // Limpiar la tabla de cálculos
            calculationsBody.innerHTML = '';

            tramoDivs.forEach((div, index) => {
                const tramoId = div.getAttribute('data-tramo');
                const velocityInput = div.querySelector(`#velocity${tramoId}`);
                const accelerationInput = div.querySelector(`#acceleration${tramoId}`);
                const durationInput = div.querySelector(`#duration${tramoId}`);

                const a = parseFloat(accelerationInput.value);
                const t = parseFloat(durationInput.value);

                if (isNaN(a) || isNaN(t) || t <= 0) {
                    // Manejar entradas inválidas
                    velocityInput.value = '0';
                    return;
                }

                if (index === 0) {
                    // Primer tramo: mantener v0 editable si es el primer tramo
                    if (tramoCount === 1) {
                        velocityInput.readOnly = false;
                        currentV0 = parseFloat(velocityInput.value) || 0;
                    } else {
                        // Si no es el primer tramo agregado, setear v0 basado en el tramo anterior
                        velocityInput.readOnly = true;
                        velocityInput.value = currentV0.toFixed(2);
                    }
                } else {
                    // Tramos posteriores: v0 calculado y read-only
                    velocityInput.readOnly = true;
                    velocityInput.value = currentV0.toFixed(2);
                }

                // Calcular v_final del tramo actual
                const v_final = currentV0 + a * t;

                // Calcular espacio recorrido en el tramo
                const s = currentV0 * t + 0.5 * a * t * t;

                // Añadir fila a la tabla de cálculos
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>Tramo ${index + 1}</td>
                    <td>${currentV0.toFixed(2)} m/s</td>
                    <td>${a.toFixed(2)} m/s²</td>
                    <td>${t.toFixed(2)} s</td>
                    <td>${v_final.toFixed(2)} m/s</td>
                    <td>${s.toFixed(2)} m</td>
                `;
                calculationsBody.appendChild(row);

                // Actualizar currentV0 para el siguiente tramo
                currentV0 = v_final;

                // Acumular la duración total
                totalDuration += t;
            });

            // Actualizar el campo de Tiempo Total
            totalTimeInput.value = totalDuration.toFixed(2);
        }

        // Función para agregar un nuevo tramo
        function addTramo() {
            tramoCount++;

            let finalVelocity = 0;
            const lastTramoDiv = tramosContainer.querySelector('.tramo:last-child');
            if (lastTramoDiv) {
                const tramoId = lastTramoDiv.getAttribute('data-tramo');
                const lastVelocityInput = lastTramoDiv.querySelector(`#velocity${tramoId}`);
                const lastAccelerationInput = lastTramoDiv.querySelector(`#acceleration${tramoId}`);
                const lastDurationInput = lastTramoDiv.querySelector(`#duration${tramoId}`);

                const lastVelocity = parseFloat(lastVelocityInput.value);
                const lastAcceleration = parseFloat(lastAccelerationInput.value);
                const lastDuration = parseFloat(lastDurationInput.value);

                if (!isNaN(lastVelocity) && !isNaN(lastAcceleration) && !isNaN(lastDuration) && lastDuration > 0) {
                    finalVelocity = lastVelocity + lastAcceleration * lastDuration;
                } else {
                    alert('Por favor, asegúrate de que el último tramo tenga valores válidos antes de agregar un nuevo tramo.');
                    tramoCount--; // Decrementar para mantener la consistencia de IDs
                    return;
                }
            }

            const tramoDiv = document.createElement('div');
            tramoDiv.classList.add('tramo');
            tramoDiv.setAttribute('data-tramo', tramoCount);
            tramoDiv.innerHTML = `
                <h4>Tramo ${tramoCount}</h4>
                <label for="velocity${tramoCount}">Velocidad Inicial (v₀${tramoCount}):</label>
                <input type="number" id="velocity${tramoCount}" value="${finalVelocity.toFixed(2)}" readonly> 

                <label for="acceleration${tramoCount}">Aceleración (a${tramoCount}):</label>
                <input type="number" id="acceleration${tramoCount}" value="10"> 

                <label for="duration${tramoCount}">Duración (t${tramoCount}):</label>
                <input type="number" id="duration${tramoCount}" value="5">

                <button class="removeTramo">Eliminar Tramo</button>
            `;
            tramosContainer.appendChild(tramoDiv);

            // Añadir eventos a los nuevos inputs
            const newAccelerationInput = tramoDiv.querySelector(`#acceleration${tramoCount}`);
            const newDurationInput = tramoDiv.querySelector(`#duration${tramoCount}`);
            newAccelerationInput.addEventListener('input', updateTramos);
            newDurationInput.addEventListener('input', updateTramos);

            updateTramos();
        }

        // Evento para agregar tramos
        addTramoButton.addEventListener('click', addTramo);

        // Evento para eliminar tramos
        tramosContainer.addEventListener('click', function(event) {
            if (event.target.classList.contains('removeTramo')) {
                const tramoDiv = event.target.parentElement;
                tramosContainer.removeChild(tramoDiv);
                updateTramos();
            }
        });

        // Variables de animación
        let tramos = [];
        let duraciones = [];
        let aceleraciones = [];
        let initialPosition = parseFloat(initialPositionInput.value) || 0; // px
        let totalTime = parseFloat(totalTimeInput.value) || 0; // s
        let startTime = null;
        let animationFrameId;
        let spaceTimeData = { t: [], x: [] };
        let velocityTimeData = { t: [], v: [] };
        let accelerationTimeData = { t: [], a: [] };
        let isAnimating = false;

        // Configurar el gráfico de espacio-tiempo
        const spaceTimeChart = new Chart(spaceTimeCtx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Espacio vs Tiempo',
                    data: [],
                    borderColor: '#2980b9',
                    fill: false,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { 
                        type: 'linear',
                        position: 'bottom',
                        title: { display: true, text: 'Tiempo (s)' },
                        beginAtZero: true,
                        suggestedMax: totalTime,
                        ticks: {
                            stepSize: 1
                        }
                    },
                    y: { 
                        title: { display: true, text: 'Espacio (m)' },
                        beginAtZero: true
                    }
                },
                plugins: {
                    legend: { display: false }
                }
            }
        });

        // Configurar el gráfico de velocidad-tiempo
        const velocityTimeChart = new Chart(velocityTimeCtx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Velocidad vs Tiempo',
                    data: [],
                    borderColor: '#27ae60',
                    fill: true, // Para el área bajo la curva
                    backgroundColor: 'rgba(39, 174, 96, 0.2)',
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { 
                        type: 'linear',
                        position: 'bottom',
                        title: { display: true, text: 'Tiempo (s)' },
                        beginAtZero: true,
                        suggestedMax: totalTime,
                        ticks: {
                            stepSize: 1
                        }
                    },
                    y: { 
                        title: { display: true, text: 'Velocidad (m/s)' },
                        beginAtZero: true
                    }
                },
                plugins: {
                    legend: { display: false }
                }
            }
        });

        // Configurar el gráfico de aceleración-tiempo
        const accelerationTimeChart = new Chart(accelerationTimeCtx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Aceleración vs Tiempo',
                    data: [],
                    borderColor: '#8e44ad',
                    fill: false,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { 
                        type: 'linear',
                        position: 'bottom',
                        title: { display: true, text: 'Tiempo (s)' },
                        beginAtZero: true,
                        suggestedMax: totalTime,
                        ticks: {
                            stepSize: 1
                        }
                    },
                    y: { 
                        title: { display: true, text: 'Aceleración (m/s²)' },
                        beginAtZero: true
                    }
                },
                plugins: {
                    legend: { display: false }
                }
            }
        });

        // Función para obtener los tramos actuales
        function getTramos() {
            const tramoDivs = tramosContainer.querySelectorAll('.tramo');
            let tramosArray = [];
            let duracionesArray = [];
            let aceleracionesArray = [];
            tramoDivs.forEach(div => {
                const tramoId = div.getAttribute('data-tramo');
                const velocityInput = div.querySelector(`#velocity${tramoId}`);
                const accelerationInput = div.querySelector(`#acceleration${tramoId}`);
                const durationInput = div.querySelector(`#duration${tramoId}`);
                const velocity = parseFloat(velocityInput.value);
                const acceleration = parseFloat(accelerationInput.value);
                const duration = parseFloat(durationInput.value);
                if (!isNaN(velocity) && !isNaN(acceleration) && !isNaN(duration) && duration > 0) {
                    tramosArray.push(velocity);
                    aceleracionesArray.push(acceleration);
                    duracionesArray.push(duration);
                }
            });
            return { tramosArray, duracionesArray, aceleracionesArray };
        }

        // Función de animación
        function animate(currentTime) {
            if (!startTime) startTime = currentTime;
            const elapsedTime = (currentTime - startTime) / 1000; // segundos

            if (elapsedTime > totalTime) {
                // Finalizar la animación al alcanzar el tiempo total
                cancelAnimationFrame(animationFrameId);
                isAnimating = false;
                finalizeCharts();
                return;
            }

            // Determinar en qué tramo estamos
            let cumulativeTime = 0;
            let currentTramoIndex = 0;
            let v0 = tramos[0];
            let a = aceleraciones[0];
            for (let i = 0; i < tramos.length; i++) {
                cumulativeTime += duraciones[i];
                if (elapsedTime <= cumulativeTime) {
                    currentTramoIndex = i;
                    v0 = tramos[i];
                    a = aceleraciones[i];
                    break;
                }
            }
            // Si excede todos los tramos, mantener el último tramo
            if (currentTramoIndex >= tramos.length) {
                currentTramoIndex = tramos.length - 1;
                v0 = tramos[currentTramoIndex];
                a = aceleraciones[currentTramoIndex];
            }

            // Calcular tiempo dentro del tramo actual
            let timeInTramo = elapsedTime;
            for (let i = 0; i < currentTramoIndex; i++) {
                timeInTramo -= duraciones[i];
            }

            // Calcular nueva posición usando MRUV
            const positionPreviousTramos = tramos.slice(0, currentTramoIndex).reduce((acc, curr, idx) => {
                return acc + curr * duraciones[idx] + 0.5 * aceleraciones[idx] * Math.pow(duraciones[idx], 2);
            }, 0);
            const newPosition = initialPosition + positionPreviousTramos + v0 * timeInTramo + 0.5 * a * Math.pow(timeInTramo, 2);

            // Calcular nueva velocidad
            const newVelocity = v0 + a * timeInTramo;

            // Actualizar posición del objeto
            object.style.left = `${newPosition}px`;

            // Actualizar gráficos
            spaceTimeData.t.push(elapsedTime.toFixed(2));
            spaceTimeData.x.push(newPosition.toFixed(2));
            spaceTimeChart.data.datasets[0].data = spaceTimeData.t.map((t, index) => ({ x: parseFloat(t), y: parseFloat(spaceTimeData.x[index]) }));
            spaceTimeChart.update();

            velocityTimeData.t.push(elapsedTime.toFixed(2));
            velocityTimeData.v.push(newVelocity.toFixed(2));
            velocityTimeChart.data.datasets[0].data = velocityTimeData.t.map((t, index) => ({ x: parseFloat(t), y: parseFloat(velocityTimeData.v[index]) }));
            velocityTimeChart.update();

            accelerationTimeData.t.push(elapsedTime.toFixed(2));
            accelerationTimeData.a.push(a.toFixed(2));
            accelerationTimeChart.data.datasets[0].data = accelerationTimeData.t.map((t, index) => ({ x: parseFloat(t), y: parseFloat(accelerationTimeData.a[index]) }));
            accelerationTimeChart.update();

            // Solicitar el siguiente frame
            animationFrameId = requestAnimationFrame(animate);
        }

        // Función para finalizar y marcar los gráficos
        function finalizeCharts() {
            // Resaltar el área bajo la curva en velocidad-tiempo (ya está relleno)

            // Calcular y marcar la pendiente en espacio-tiempo
            if (spaceTimeData.t.length > 1) {
                const t1 = parseFloat(spaceTimeData.t[0]);
                const x1 = parseFloat(spaceTimeData.x[0]);
                const t2 = parseFloat(spaceTimeData.t[spaceTimeData.t.length -1]);
                const x2 = parseFloat(spaceTimeData.x[spaceTimeData.x.length -1]);
                const slope = (x2 - x1) / (t2 - t1);

                // Añadir una línea de la pendiente
                const slopeDataset = {
                    label: 'Pendiente (v)',
                    data: [
                        { x: t1, y: x1 },
                        { x: t2, y: x2 }
                    ],
                    borderColor: '#e67e22',
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    borderDash: [5, 5]
                };
                spaceTimeChart.data.datasets.push(slopeDataset);
                spaceTimeChart.update();
            }
        }

        // Función para iniciar la animación
        function startAnimation() {
            if (isAnimating) return; // Evitar múltiples animaciones

            // Obtener parámetros
            initialPosition = parseFloat(initialPositionInput.value) || 0;
            totalTime = parseFloat(totalTimeInput.value) || 0;

            // Validar entradas
            if (isNaN(initialPosition)) {
                alert('Por favor, ingresa una posición inicial válida.');
                return;
            }
            if (isNaN(totalTime) || totalTime <= 0) {
                alert('Por favor, asegúrate de que hay tramos con duraciones válidas.');
                return;
            }

            const { tramosArray, duracionesArray, aceleracionesArray } = getTramos();
            if (tramosArray.length === 0) {
                alert('Por favor, agrega al menos un tramo con velocidad, aceleración y duración válidas.');
                return;
            }

            // Calcular la duración total de los tramos
            const sumDurations = duracionesArray.reduce((acc, curr) => acc + curr, 0);
            if (sumDurations > totalTime) {
                alert('La suma de las duraciones de los tramos excede el tiempo total.');
                return;
            }

            tramos = tramosArray;
            duraciones = duracionesArray;
            aceleraciones = aceleracionesArray;

            // Resetear gráficos
            spaceTimeData = { t: [], x: [] };
            velocityTimeData = { t: [], v: [] };
            accelerationTimeData = { t: [], a: [] };

            spaceTimeChart.data.datasets[0].data = [];
            spaceTimeChart.update();
            velocityTimeChart.data.datasets[0].data = [];
            velocityTimeChart.update();
            accelerationTimeChart.data.datasets[0].data = [];
            accelerationTimeChart.update();

            // Remover cualquier pendiente previa en espacio-tiempo
            spaceTimeChart.data.datasets = spaceTimeChart.data.datasets.filter(ds => ds.label !== 'Pendiente (v)');
            spaceTimeChart.update();

            // Ajustar los límites de las gráficas según el tiempo total
            spaceTimeChart.options.scales.x.suggestedMax = totalTime;
            velocityTimeChart.options.scales.x.suggestedMax = totalTime;
            accelerationTimeChart.options.scales.x.suggestedMax = totalTime;

            spaceTimeChart.update();
            velocityTimeChart.update();
            accelerationTimeChart.update();

            // Resetear posición del objeto
            object.style.left = `${initialPosition}px`;

            // Iniciar animación
            startTime = null;
            isAnimating = true;
            animationFrameId = requestAnimationFrame(animate);
        }

        // Función para reiniciar la animación
        function resetAnimation() {
            cancelAnimationFrame(animationFrameId);
            isAnimating = false;
            spaceTimeData = { t: [], x: [] };
            velocityTimeData = { t: [], v: [] };
            accelerationTimeData = { t: [], a: [] };

            spaceTimeChart.data.datasets[0].data = [];
            spaceTimeChart.update();
            velocityTimeChart.data.datasets[0].data = [];
            velocityTimeChart.update();
            accelerationTimeChart.data.datasets[0].data = [];
            accelerationTimeChart.update();

            // Remover cualquier pendiente previa en espacio-tiempo
            spaceTimeChart.data.datasets = spaceTimeChart.data.datasets.filter(ds => ds.label !== 'Pendiente (v)');
            spaceTimeChart.update();

            // Resetear posición del objeto
            const initialPos = parseFloat(initialPositionInput.value);
            if (!isNaN(initialPos)) {
                object.style.left = `${initialPos}px`;
            } else {
                object.style.left = `0px`;
            }

            // Limpiar la tabla de cálculos
            calculationsBody.innerHTML = '';
        }

        // Asignar eventos a los botones
        startButton.addEventListener('click', startAnimation);
        resetButton.addEventListener('click', resetAnimation);

        // Asignar eventos a los inputs de aceleración y duración para actualizar tramos
        function assignEventListeners() {
            const tramoDivs = tramosContainer.querySelectorAll('.tramo');
            tramoDivs.forEach(div => {
                const tramoId = div.getAttribute('data-tramo');
                const accelerationInput = div.querySelector(`#acceleration${tramoId}`);
                const durationInput = div.querySelector(`#duration${tramoId}`);
                accelerationInput.addEventListener('input', updateTramos);
                durationInput.addEventListener('input', updateTramos);
            });
        }

        // Asignar eventos al cargar la página
        window.onload = function() {
            assignEventListeners();
            updateTramos();
        };
    </script>
</body>
</html>